// ---------------------------------------------------------------------------
//
// This file is part of:
//
// FRIDA - FRee Interactive DisAssembler
// Copyright (C) 2017,2023 Ivo van Poorten
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; ONLY version 2 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//
// ---------------------------------------------------------------------------

#include "exportassembly.h"
#include "exportassemblywindow.h"

static int error;
extern QString errorstring;
static int asm_format;

// ---------------------------------------------------------------------------

// Output formats

static void mads_assembler(QString *instr) {
    instr->replace(QStringLiteral(".wordle"), QStringLiteral(".word"));
    instr->replace(QStringLiteral(".atascii"), QStringLiteral(".byte"));
    instr->replace(QStringLiteral(".anticscreen"), QStringLiteral(".sb"));
    instr->replace(QStringLiteral(".invatascii"), QStringLiteral(".byte +128"));
    instr->replace(QStringLiteral(".invanticscreen"), QStringLiteral(".sb +128"));
    instr->replace(QStringLiteral(".org"), QStringLiteral("org"));
}

static void ca65_assembler(QString *instr) {
    instr->replace(QStringLiteral(".wordle"), QStringLiteral(".word"));
    instr->replace(QStringLiteral(".ascii"), QStringLiteral(".byte"));
    instr->replace(QStringLiteral(".atascii"), QStringLiteral(".byte"));
}

// ---------------------------------------------------------------------------

static void write_line(QTextStream *out) {
    *out << "; ----------------------------------------------------------";
    *out << "------------------\n";
}

// ---------------------------------------------------------------------------

void export_assembly(QWidget *widget, bool generateLocalLabels) {
    auto *asw = new exportAssemblyWindow();

    asw->exec();

    if (asw->result() == QDialog::Rejected) return;

    asm_format = asw->asm_format;

    QString name = QFileDialog::getSaveFileName(widget, QStringLiteral("Export Assembly As..."));

    if (name.isEmpty()) return;

    QFile file(name);

    file.open(QIODevice::WriteOnly);
    if (!file.isOpen()) {
        QMessageBox msg;
        msg.setText("Failed to open " + name + "\n\n" + file.errorString());
        msg.exec();
        return;
    }

    QString hexPrefix = Disassembler->hexPrefix;
    QString hexSuffix = Disassembler->hexSuffix;

    QTextStream out(&file);

    write_line(&out);
    out << "\n; Generated by Frida version ";
    out << FRIDA_VERSION_STRING;
    out << "\n\n; ";
    out << QDateTime::currentDateTime().toString();
    out << "\n\n";
    write_line(&out);

    if (!constantsGroups.isEmpty()) {

        out << "\n; CONSTANTS\n";

        for (const auto &group : qAsConst(constantsGroups)) {
            if (!group.map->isEmpty()) {
                out << "\n; " << group.name << "\n\n";

                QMap<quint64, QString>::iterator iter;

                for (iter = group.map->begin(); iter != group.map->end(); ++iter) {
                    out << iter.value() << " = " << iter.key() << "\n";
                }
            }
        }
    }

    out << "\n; GENERATED LABELS\n\n";

    QMap<quint64, QString>::const_iterator iter;

    // output all glocal labels that are not overruled by local labels and are
    // not within any of the segments address ranges.
    // also omit labels that have +/- math inside them

    for(iter = globalLabels.constBegin(); iter != globalLabels.constEnd(); ++iter) {

        if (iter.value().contains(QStringLiteral("+")) || iter.value().contains(QStringLiteral("-")))
            continue;

        bool found_local = false;
        for (auto & segment : segments) {
            if (segment.localLabels.contains(iter.key())) {
                found_local = true;
                break;
            }
        }
        if (found_local)
            continue;

        bool inside_segment = false;
        for (auto & segment : segments) {
            quint64 start = segment.start;
            quint64 end   = segment.end;
            quint64 key = iter.key();
            if ((key >= start) && (key <= end)) {
                inside_segment = true;
                break;
            }
        }
        if (inside_segment)
            continue;

        out << iter.value() << '=' << hexPrefix;
        out << QStringLiteral("%1").arg(iter.key(), 0, 16) << hexSuffix << "\n";
    }

    out << "\n";
    write_line(&out);

    // output each segment, starting with its local labels, and then its
    // dissassembly

    int saveCurrentSegment = currentSegment;

    for (int i=0; i<segments.size(); i++) {
        struct segment *s = &segments[i];

        currentSegment = i;
        Disassembler->generateDisassembly(generateLocalLabels);

        out << "\n; SEGMENT: " << i+1 << "\n\n";
        out << "; Name    : " << s->name << "\n";
        out << "; Start   : ";
        out << hexPrefix << QStringLiteral("%1").arg(s->start, 0, 16) << hexSuffix;
        out << "\n; End     : ";
        out << hexPrefix << QStringLiteral("%1").arg(s->end, 0, 16) << hexSuffix;
        out << "\n\n; LOCAL LABELS\n\n";

        // output local labels that are not inside a segment or contain +/-

        for(iter  = s->localLabels.constBegin();
            iter != s->localLabels.constEnd(); ++iter) {

            if (iter.value().contains(QStringLiteral("+")) || iter.value().contains(QStringLiteral("-")))
                continue;

            bool inside_segment = false;
            for (auto & segment : segments) {
                quint64 start = segment.start;
                quint64 end   = segment.end;
                quint64 key = iter.key();
                if ((key >= start) && (key <= end)) {
                    inside_segment = true;
                    break;
                }
            }
            if (inside_segment)
                continue;

            out << iter.value() << '=' << hexPrefix;
            out << QStringLiteral("%1").arg(iter.key(), 0, 16) << hexSuffix << "\n";
        }

        out << "\n";

        // output disassembly

        QList<struct disassembly> *dislist  = &s->disassembly;
        QMap<quint64, QString> *comments     = &s->comments;
        struct disassembly dis;
        QString com;

        qint64 di = 0;
        while (di < dislist->size()) {
            dis = dislist->at(di);

            if (comments->contains(dis.address)) {
                com = comments->value(dis.address);
                com.replace(QStringLiteral("\n"), QStringLiteral("\n; "));
                out << "; " << com << "\n";
            }

            if (dis.address && (globalLabels.contains(dis.address)
                || s->localLabels.contains(dis.address))) {

                QString label;
                if (s->localLabels.contains(dis.address))
                    label = s->localLabels.value(dis.address);
                else
                    label = globalLabels.value(dis.address);

                // we do not print labels with + or -

                if (!label.contains(QChar('+')) && !label.contains(QChar('-'))) {
                    out << label << "\n";
                }
            }

            QString instruction = dis.instruction;

            if (asm_format == ASM_FORMAT_MADS) {
                mads_assembler(&instruction);
            } else if (asm_format == ASM_FORMAT_CA65) {
                ca65_assembler(&instruction);
            }

            out << "    " << instruction << " " << dis.arguments << "\n";

            if (dis.changes_pc) {
                out << "\n";
            }

            di++;
        }

        out << "\n";
        write_line(&out);
    }

    currentSegment = saveCurrentSegment;

    error = file.error();
    errorstring = file.errorString();

    file.close();

    QMessageBox msg;

    if (error != file.NoError) {
        msg.setText("Failed to export " + name + "\n\n" + errorstring);
        msg.exec();
    } else {
        msg.setText("Succesfully exported " + name + "\n");
        msg.exec();
    }
}
